#!/usr/bin/env python

#this script is intended to be run out of $PEBIL_ROOT/scripts

import sys
import os
import string
from xml.dom import minidom

xmldocument = '../docs/ioevents.xml'
headerfile  = 'IOEvents.h'
sourcefile  = 'IOEvents.c'
wrapperfile = '../scripts/inputlist/iowrappers.inp'
wrapperpost = '_pebil_wrapper'

mapClassToNames = {
    'CLIB': ['', '_IO_', '__'],
    'POSX': ['', '__libc_', '__'],
    'MPIO': ['', 'P'],
    'HDF5': []
}

mapTypeToFormat = {
    'FILE*':        '%d',
    'int':          '%d',
    'const char*':  '%s',
    'mode_t':       '%d',
    'const void*':  '%d',
    'size_t':       '%d',
    'off_t':        '%d',
    'struct stat*': '%d',
    'long int':     '%lld',
    'MPI_Comm':     '%d',
    'char*':        '%s',
    'MPI_Info':     '%d',
    'MPI_File':     '%d',
    'void*':        '%d',
    'MPI_Offset':   '%d',
    'MPI_Status*':  '%d',
    'MPI_DataType': '%d'
}

dom = minidom.parse(xmldocument)

classes = dom.getElementsByTagName('ioclass')
classNames = [str(c.getAttribute('class')) for c in classes]

def buildEnumeration(pattern, elist):
    enum = 'typedef enum {\n'
    elist.insert(0,'Invalid')
    for item in elist:
        enum += '\t' + pattern + '_' + item + ',\n'
    sizestr = pattern + '_Total_Types'
    enum += '\t' + sizestr + '\n'
    enum += '} ' + pattern + '_t;\n'

    enum += 'extern const char* ' + pattern + 'Names[' + sizestr + '];\n'
    enum += 'const char* ' + pattern + 'Names[' + sizestr + '] = {\n'
    enum += string.join(['\t"' + item for item in elist], '",\n')
    enum += '"\n};\n\n'

    return enum

def buildFunctionCode(funcdom):
    rettype = str(funcdom.getAttribute('ret'))
    fname = string.strip(funcdom.firstChild.data)
    specials = f.getElementsByTagName('special')

    # function declaration
    code = str(rettype) + ' __wrapper_name(' + str(fname) + ')'
    args = f.getElementsByTagName('arg')
    code += '(' + string.join([str(a.getAttribute('type')) + ' ' + string.strip(a.firstChild.data) for a in args],', ') + ')\n{\n'

    # special location 0 -- function entry
    for s in specials:
        if cmp(s.getAttribute('location'),'0') == 0:
            code += '\t' + string.strip(s.firstChild.data) + '\n'

    code += '\t' + str(rettype) + ' retval;\n'
    code += '#ifdef PRELOAD_WRAPPERS\n'
    code += '\tstatic ' + str(rettype) + ' *(*' + str(fname) + '_ptr)('
    code += string.join([str(a.getAttribute('type')) + ' ' + string.strip(a.firstChild.data) for a in args],', ') + ');\n'
    code += '\t' + str(fname) + '_ptr = dlsym(RTLD_NEXT, "' + fname + '");\n'
    code += '\tTIMER_EXECUTE(retval = ' + str(fname) + '_ptr(' + string.join([string.strip(a.firstChild.data) for a in args], ', ') + ');)\n'
    code += '#else // PRELOAD_WRAPPERS\n'
    code += '\tTIMER_EXECUTE(retval = ' + str(fname) + '(' + string.join([string.strip(a.firstChild.data) for a in args], ', ') + ');)\n'
    code += '#endif // PRELOAD_WRAPPERS\n'

    # special location 1 -- after call, before msg print
    for s in specials:
        if cmp(s.getAttribute('location'),'1') == 0:
            code += '\t' + string.strip(s.firstChild.data) + '\n'

    code += '\tsprintf(message, "' + string.strip(funcdom.parentNode.firstChild.data) + '_' + str(fname) + '('
    code += string.join([string.strip(a.firstChild.data) + '=' + mapTypeToFormat[str(a.getAttribute('type'))] for a in args], ', ')
    code += ')\\n", ' + string.join([string.strip(a.firstChild.data) for a in args], ', ') + ');\n'
    code += '\tstoreToBuffer(message, strlen(message));\n'

    # special location 2 -- before return
    for s in specials:
        if cmp(s.getAttribute('location'),'2') == 0:
            code += '\t' + string.strip(s.firstChild.data) + '\n'

    code += '\treturn retval;\n'
    code += '}\n\n'
    return code

##############################################################
# print header file
##############################################################
header = open(headerfile, 'w')
header.write('// automatically generated by ' + str(sys.argv[0]) + '\n')
header.write('#ifndef _IOEVENTS_H_\n#define _IOEVENTS_H_\n\n')
header.write('#ifdef PRELOAD_WRAPPERS\n#define _GNU_SOURCE\n#include <dlfcn.h>\n#endif\n\n')
header.write('#include <stdio.h>\n\n')
header.write(buildEnumeration('IOEventClass', [string.strip(c.firstChild.data) for c in classes]))
classFuncs = []
for c in classes:
    funcs = c.getElementsByTagName('function')
    for f in funcs:
        classFuncs.append(string.strip(c.firstChild.data) + '_' + string.strip(f.firstChild.data))
header.write(buildEnumeration('IOEvent', classFuncs))
header.write('#endif // _IOEVENTS_H_')
header.close()

##############################################################
# print source file
##############################################################
source = open(sourcefile, 'w')
source.write('// automatically generated by ' + str(sys.argv[0]) + '\n')
source.write('#include <stdio.h>\n')
source.write('#include <' + headerfile + '>\n\n')
for c in classes:
    funcs = c.getElementsByTagName('function')
    for f in funcs:
        source.write(buildFunctionCode(f))
source.close()

##############################################################
# print call->wrapper file (for pebil's --trk)
##############################################################
wrapper = open(wrapperfile, 'w')
wrapper.write('# automatically generated by ' + str(sys.argv[0]) + '\n')
for c in classes:
    cName = string.strip(c.firstChild.data)
    wrapper.write('# ' + cName + ' wrappers\n')
    funcs = c.getElementsByTagName('function')
    prefixes = mapClassToNames[cName]
    for f in funcs:
        fName = string.strip(f.firstChild.data)
        for p in prefixes:
            wrapper.write(p + fName + ':' + fName + wrapperpost + '\n')
wrapper.close()
